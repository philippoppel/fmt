generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DATABASE_URL_UNPOOLED")
}

// Enums for TherapistProfile
enum SessionType {
  online
  in_person
  both
}

enum Availability {
  immediately
  this_week
  flexible
}

enum Gender {
  male
  female
  diverse
}

// Therapy Style Enums for Matching
enum CommunicationStyle {
  directive   // Klar & strukturiert - gibt konkrete Anleitungen
  empathetic  // Einfühlsam & begleitend - hört vor allem zu
  balanced    // Ausgewogen - passt sich an
}

enum TherapyFocus {
  past        // Vergangenheit verstehen - Ursachen und Muster erkennen
  present     // Gegenwart bewältigen - aktuelle Probleme lösen
  future      // Zukunft gestalten - Ziele setzen und erreichen
  holistic    // Ganzheitlich - alle Zeitebenen
}

enum TherapyDepth {
  symptom_relief  // Akute Symptomlinderung - schnelle Hilfe
  deep_change     // Tiefgreifende Veränderung - langfristig
  flexible        // Flexibel - je nach Bedarf
}

// Account-Typen für Therapeuten-Profile
enum AccountType {
  gratis    // Basis: kein Bild, 1 Schwerpunkt, Basisprofil
  mittel    // Mittel: 1-2 Schwerpunkte mit Ranking, einfaches Bild
  premium   // Premium: 1-3 Schwerpunkte mit Ranking, volles Profil
}

// Blog Enums
enum PostStatus {
  draft
  published
  archived
}

model User {
  id                    String    @id @default(cuid())
  name                  String?
  email                 String    @unique
  emailVerified         DateTime?
  image                 String?
  password              String?

  // 2FA Support
  twoFactorEnabled      Boolean   @default(false)
  twoFactorSecret       String?

  // Backup Codes für 2FA
  backupCodes           String[]

  // Account Status
  isActive              Boolean   @default(true)
  failedLoginAttempts   Int       @default(0)
  lockedUntil           DateTime?

  // Timestamps
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Relations
  accounts              Account[]
  sessions              Session[]
  therapistProfile      TherapistProfile?

  // Blog Relations
  blogPosts             BlogPost[]
  comments              Comment[]
  bookmarks             Bookmark[]
  blogDrafts            BlogDraft[]

  @@map("users")
}

model Account {
  id                    String  @id @default(cuid())
  userId                String
  type                  String
  provider              String
  providerAccountId     String
  refresh_token         String? @db.Text
  access_token          String? @db.Text
  expires_at            Int?
  token_type            String?
  scope                 String?
  id_token              String? @db.Text
  session_state         String?

  user                  User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id                    String   @id @default(cuid())
  sessionToken          String   @unique
  userId                String
  expires               DateTime

  // Additional session info
  userAgent             String?
  ipAddress             String?

  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier            String
  token                 String   @unique
  expires               DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model PasswordResetToken {
  id                    String   @id @default(cuid())
  email                 String
  token                 String   @unique
  expires               DateTime

  createdAt             DateTime @default(now())

  @@unique([email, token])
  @@map("password_reset_tokens")
}

model TwoFactorToken {
  id                    String   @id @default(cuid())
  email                 String
  token                 String   @unique
  expires               DateTime

  createdAt             DateTime @default(now())

  @@unique([email, token])
  @@map("two_factor_tokens")
}

model AuditLog {
  id                    String   @id @default(cuid())
  userId                String?
  action                String
  entityType            String?
  entityId              String?
  metadata              Json?
  ipAddress             String?
  userAgent             String?

  createdAt             DateTime @default(now())

  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

model TherapistProfile {
  id                String       @id @default(cuid())
  userId            String       @unique

  // Basic Info
  title             String?
  imageUrl          String?
  shortDescription  String?      @db.Text

  // Location
  city              String?
  postalCode        String?

  // Professional Details (stored as string arrays)
  specializations   String[]
  therapyTypes      String[]
  languages         String[]
  insurance         String[]

  // Pricing & Availability
  pricePerSession   Int?         @default(0)
  sessionType       SessionType  @default(both)
  availability      Availability @default(flexible)
  gender            Gender?

  // Ratings
  rating            Float        @default(0)
  reviewCount       Int          @default(0)

  // Therapy Style (for Matching)
  communicationStyle  CommunicationStyle?  @default(balanced)
  usesHomework        Boolean?             @default(true)
  therapyFocus        TherapyFocus?        @default(holistic)
  clientTalkRatio     Int?                 @default(50)  // 0-100: wie viel % redet Patient
  therapyDepth        TherapyDepth?        @default(flexible)

  // Account & Verification
  accountType         AccountType          @default(gratis)
  isVerified          Boolean              @default(false)
  experienceYears     Int?                 // Jahre Berufserfahrung

  // Schwerpunkt-Ranking (JSON: {"anxiety": 1, "depression": 2, "trauma": 3})
  specializationRanks Json?                @default("{}")

  // Profil-Vollständigkeit für Qualitäts-Bonus (0-100)
  profileCompleteness Int                  @default(0)

  // Profile visibility
  isPublished       Boolean      @default(true)

  // Timestamps
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt

  // Relations
  user              User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  matchInteractions MatchInteraction[]

  @@index([city])
  @@index([isPublished])
  @@map("therapist_profiles")
}

// ============================================
// BLOG MODELS
// ============================================

model BlogPost {
  id                String         @id @default(cuid())
  slug              String         @unique

  // Content
  title             String
  content           Json           // TipTap JSON content
  contentHtml       String         @db.Text // Pre-rendered HTML for SEO
  excerpt           String?        @db.Text // Auto-generated excerpt

  // Summary (Pflichtfeld)
  summaryShort      String         @db.VarChar(280) // TLDR kurz
  summaryMedium     String?        @db.Text // Mittlere Zusammenfassung

  // Media
  featuredImage     String?        // Cloudinary URL
  featuredImageAlt  String?        // Alt-Text fuer A11y

  // Meta & SEO
  metaTitle         String?        @db.VarChar(60)
  metaDescription   String?        @db.VarChar(160)
  canonicalUrl      String?

  // Reading
  readingTimeMinutes Int           @default(0)
  wordCount         Int            @default(0)

  // Status & Visibility
  status            PostStatus     @default(draft)
  publishedAt       DateTime?

  // Author
  authorId          String
  author            User           @relation(fields: [authorId], references: [id], onDelete: Cascade)

  // Relations
  categories        BlogPostCategory[]
  tags              BlogPostTag[]
  citations         Citation[]
  comments          Comment[]
  bookmarks         Bookmark[]

  // Timestamps
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  @@index([authorId])
  @@index([status])
  @@index([publishedAt])
  @@index([slug])
  @@map("blog_posts")
}

model BlogCategory {
  id              String              @id @default(cuid())
  slug            String              @unique
  name            String              // Internal name
  nameDE          String              // German translation
  nameEN          String              // English translation
  description     String?             @db.Text
  descriptionDE   String?             @db.Text
  descriptionEN   String?             @db.Text
  color           String?             // Hex color for UI
  icon            String?             // Lucide icon name
  sortOrder       Int                 @default(0)

  // SEO
  metaTitleDE     String?             @db.VarChar(60)
  metaTitleEN     String?             @db.VarChar(60)
  metaDescDE      String?             @db.VarChar(160)
  metaDescEN      String?             @db.VarChar(160)

  posts           BlogPostCategory[]

  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  @@map("blog_categories")
}

model BlogPostCategory {
  postId          String
  categoryId      String
  post            BlogPost            @relation(fields: [postId], references: [id], onDelete: Cascade)
  category        BlogCategory        @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@id([postId, categoryId])
  @@map("blog_post_categories")
}

model BlogTag {
  id              String              @id @default(cuid())
  slug            String              @unique
  name            String

  posts           BlogPostTag[]

  createdAt       DateTime            @default(now())

  @@map("blog_tags")
}

model BlogPostTag {
  postId          String
  tagId           String
  post            BlogPost            @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag             BlogTag             @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([postId, tagId])
  @@map("blog_post_tags")
}

model Citation {
  id              String              @id @default(cuid())

  // DOI Support
  doi             String?

  // Bibliographic Data
  title           String
  authors         String[]            // Array of author names
  journal         String?
  year            Int?
  volume          String?
  issue           String?
  pages           String?
  publisher       String?
  url             String?
  accessDate      DateTime?

  // Citation Type
  type            String              @default("article") // article, book, website, etc.

  // Formatted citations (cached)
  formattedAPA    String?             @db.Text

  // Relation to post
  postId          String
  post            BlogPost            @relation(fields: [postId], references: [id], onDelete: Cascade)

  // Position in post (for inline citations)
  inlineKey       String              // e.g. "smith2023" for [Smith, 2023]

  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  @@index([postId])
  @@index([doi])
  @@map("citations")
}

model Comment {
  id              String              @id @default(cuid())
  content         String              @db.Text

  // Author (registered user or guest)
  authorId        String?
  author          User?               @relation(fields: [authorId], references: [id], onDelete: SetNull)
  guestName       String?
  guestEmail      String?

  // Post relation
  postId          String
  post            BlogPost            @relation(fields: [postId], references: [id], onDelete: Cascade)

  // Nested comments
  parentId        String?
  parent          Comment?            @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies         Comment[]           @relation("CommentReplies")

  // Moderation
  isApproved      Boolean             @default(false)
  isSpam          Boolean             @default(false)

  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  @@index([postId])
  @@index([authorId])
  @@index([parentId])
  @@map("comments")
}

model Bookmark {
  id              String              @id @default(cuid())

  userId          String
  user            User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  postId          String
  post            BlogPost            @relation(fields: [postId], references: [id], onDelete: Cascade)

  // Reading progress
  readProgress    Float               @default(0) // 0-100%
  lastReadAt      DateTime?

  createdAt       DateTime            @default(now())

  @@unique([userId, postId])
  @@index([userId])
  @@map("bookmarks")
}

model BlogDraft {
  id              String              @id @default(cuid())

  // Link to existing post (null for new posts)
  postId          String?             @unique

  // Author
  authorId        String
  author          User                @relation(fields: [authorId], references: [id], onDelete: Cascade)

  // Draft content
  content         Json                // TipTap JSON
  title           String?
  summaryShort    String?             @db.VarChar(280)

  // Autosave metadata
  savedAt         DateTime            @default(now())

  @@index([authorId])
  @@map("blog_drafts")
}

// ============================================
// MATCHING & ML MODELS
// ============================================

// Anonyme Interaktions-Daten für ML-Optimierung
model MatchInteraction {
  id              String   @id @default(cuid())
  sessionId       String   // Anonyme Session-ID (ohne User-Zuordnung)
  therapistId     String
  therapist       TherapistProfile @relation(fields: [therapistId], references: [id], onDelete: Cascade)

  // Interaktionstyp
  action          String   // "view" | "click" | "contact"

  // Kontext zum Zeitpunkt der Interaktion
  matchScore      Int?
  searchCriteria  Json?    // Anonymisierte Matching-Kriterien

  timestamp       DateTime @default(now())

  @@index([sessionId])
  @@index([therapistId])
  @@index([timestamp])
  @@map("match_interactions")
}

// Anonymes Nutzer-Feedback nach Matching
model MatchFeedback {
  id              String   @id @default(cuid())
  sessionId       String   // Anonyme Session-ID

  // Feedback-Daten
  foundMatch      Boolean? // "Haben Sie jemanden gefunden?"
  relevanceRating Int?     // 1-5 Sterne

  // Optional: Freitext-Feedback
  feedbackText    String?  @db.Text

  timestamp       DateTime @default(now())

  @@index([sessionId])
  @@index([timestamp])
  @@map("match_feedback")
}
