generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DATABASE_URL_UNPOOLED")
}

// Enums for TherapistProfile
enum SessionType {
  online
  in_person
  both
}

enum Availability {
  immediately
  this_week
  flexible
}

enum Gender {
  male
  female
  diverse
}

// Therapy Style Enums for Matching
enum CommunicationStyle {
  directive   // Klar & strukturiert - gibt konkrete Anleitungen
  empathetic  // Einfühlsam & begleitend - hört vor allem zu
  balanced    // Ausgewogen - passt sich an
}

enum TherapyFocus {
  past        // Vergangenheit verstehen - Ursachen und Muster erkennen
  present     // Gegenwart bewältigen - aktuelle Probleme lösen
  future      // Zukunft gestalten - Ziele setzen und erreichen
  holistic    // Ganzheitlich - alle Zeitebenen
}

enum TherapyDepth {
  symptom_relief  // Akute Symptomlinderung - schnelle Hilfe
  deep_change     // Tiefgreifende Veränderung - langfristig
  flexible        // Flexibel - je nach Bedarf
}

// Account-Typen für Therapeuten-Profile
enum AccountType {
  gratis    // Basis: kein Bild, 1 Schwerpunkt, Basisprofil
  mittel    // Mittel: 1-2 Schwerpunkte mit Ranking, einfaches Bild
  premium   // Premium: 1-3 Schwerpunkte mit Ranking, volles Profil
}

// Subscription Status für Tier-Wechsel
enum SubscriptionStatus {
  none       // Kein aktives Abo (gratis)
  active     // Aktives Abo
  canceled   // Gekündigt, läuft noch bis Periodenende
  past_due   // Zahlung fehlgeschlagen
}

// Microsite Status
enum MicrositeStatus {
  draft
  published
}

// Blog Enums
enum PostStatus {
  draft
  review      // Submitted for admin review
  scheduled   // Approved, waiting for publish date
  published
  archived
}

// ============================================
// LABELLING PORTAL ENUMS
// ============================================

enum UserRole {
  USER      // Default for normal users
  LABELLER  // Can create and label cases
  ADMIN     // Full access + user management
}

enum CaseSource {
  MANUAL
  IMPORT
  AI_SEEDED
}

enum CaseStatus {
  NEW
  LABELED
  REVIEW
}

enum RelatedTopicStrength {
  OFTEN
  SOMETIMES
}

model User {
  id                    String    @id @default(cuid())
  name                  String?
  email                 String    @unique
  emailVerified         DateTime?
  image                 String?
  password              String?

  // Email Verification
  emailVerificationToken   String?   @unique
  emailVerificationExpires DateTime?

  // 2FA Support
  twoFactorEnabled      Boolean   @default(false)
  twoFactorSecret       String?

  // Backup Codes für 2FA
  backupCodes           String[]

  // Account Status
  isActive              Boolean   @default(true)
  failedLoginAttempts   Int       @default(0)
  lockedUntil           DateTime?

  // Role for labelling portal
  role                  UserRole  @default(USER)

  // Timestamps
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Relations
  accounts              Account[]
  sessions              Session[]
  therapistProfile      TherapistProfile?

  // Blog Relations
  blogPosts             BlogPost[]
  editedBlogPosts       BlogPost[]   @relation("BlogEditor")
  blogReviews           BlogReview[]
  blogPostVersions      BlogPostVersion[]
  blogSeries            BlogSeries[]
  blogReactions         BlogReaction[]
  comments              Comment[]
  bookmarks             Bookmark[]
  blogDrafts            BlogDraft[]

  // Labelling Portal Relations
  createdCases          LabellingCase[]  @relation("CreatedCases")
  ratedLabels           Label[]          @relation("RatedLabels")
  triggeredModelRuns    ModelRun[]       @relation("TriggeredModelRuns")

  @@map("users")
}

model Account {
  id                    String  @id @default(cuid())
  userId                String
  type                  String
  provider              String
  providerAccountId     String
  refresh_token         String? @db.Text
  access_token          String? @db.Text
  expires_at            Int?
  token_type            String?
  scope                 String?
  id_token              String? @db.Text
  session_state         String?

  user                  User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id                    String   @id @default(cuid())
  sessionToken          String   @unique
  userId                String
  expires               DateTime

  // Additional session info
  userAgent             String?
  ipAddress             String?

  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier            String
  token                 String   @unique
  expires               DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model PasswordResetToken {
  id                    String   @id @default(cuid())
  email                 String
  token                 String   @unique
  expires               DateTime

  createdAt             DateTime @default(now())

  @@unique([email, token])
  @@map("password_reset_tokens")
}

model TwoFactorToken {
  id                    String   @id @default(cuid())
  email                 String
  token                 String   @unique
  expires               DateTime

  createdAt             DateTime @default(now())

  @@unique([email, token])
  @@map("two_factor_tokens")
}

model AuditLog {
  id                    String   @id @default(cuid())
  userId                String?
  action                String
  entityType            String?
  entityId              String?
  metadata              Json?
  ipAddress             String?
  userAgent             String?

  createdAt             DateTime @default(now())

  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

model TherapistProfile {
  id                String       @id @default(cuid())
  userId            String       @unique

  // SEO-friendly URL slug (e.g., "dr-maria-schneider")
  slug              String?      @unique

  // Basic Info
  title             String?
  imageUrl          String?
  shortDescription  String?      @db.Text

  // Extended Profile Info for Personal Website
  headline          String?      // "Ihre einfühlsame Begleitung auf dem Weg zu mehr Lebensfreude"
  longDescription   String?      @db.Text  // Detailed "Über mich" section
  education         String[]     // Ausbildung & Qualifikationen
  certifications    String[]     // Zertifizierungen
  memberships       String[]     // Berufsverbände & Mitgliedschaften

  // Profile Images (Gallery)
  galleryImages     String[]     // Array of image URLs for gallery

  // Contact & Social
  phone             String?
  email             String?      // Public contact email (separate from login)
  website           String?
  linkedIn          String?
  instagram         String?

  // Profile Theme/Colors
  themeColor        String?      @default("#8B7355") // Primary accent color
  themeName         String?      @default("warm")    // "warm", "cool", "nature", "professional"

  // Office/Practice Details
  practiceName      String?      // Name der Praxis
  street            String?
  officeImages      String[]     // Praxis-Bilder

  // Working Hours (JSON structure)
  workingHours      Json?        // {"monday": {"from": "09:00", "to": "18:00"}, ...}

  // First Session Info Extended
  consultationInfo  String?      @db.Text  // Was erwartet Sie im Erstgespräch

  // Location
  city              String?
  postalCode        String?

  // Professional Details (stored as string arrays)
  specializations   String[]
  therapyTypes      String[]
  therapySettings   String[]   // ["individual", "group", "couples", "corporate"]
  languages         String[]
  insurance         String[]

  // Pricing & Availability
  pricePerSession   Int?         @default(0)
  sessionType       SessionType  @default(both)
  availability      Availability @default(flexible)
  gender            Gender?

  // Ratings
  rating            Float        @default(0)
  reviewCount       Int          @default(0)

  // Therapy Style (for Matching)
  communicationStyle  CommunicationStyle?  @default(balanced)
  usesHomework        Boolean?             @default(true)
  therapyFocus        TherapyFocus?        @default(holistic)
  clientTalkRatio     Int?                 @default(50)  // 0-100: wie viel % redet Patient
  therapyDepth        TherapyDepth?        @default(flexible)

  // Account & Verification
  accountType         AccountType          @default(gratis)
  isVerified          Boolean              @default(false)
  experienceYears     Int?                 // Jahre Berufserfahrung

  // Subscription Management
  subscriptionId        String?              // Mock Stripe subscription ID
  subscriptionStatus    SubscriptionStatus   @default(none)
  subscriptionStartedAt DateTime?
  subscriptionEndsAt    DateTime?            // Für Kündigung: Zugriff bis hier
  lastPaymentAt         DateTime?
  nextBillingDate       DateTime?

  // Schwerpunkt-Ranking (JSON: {"anxiety": 1, "depression": 2, "trauma": 3})
  specializationRanks Json?                @default("{}")

  // Custom Icons für Schwerpunkte (JSON: {"anxiety": "Zap", "depression": "Brain"})
  specializationIcons Json?                @default("{}")

  // Sub-Spezialisierungen für präziseres Matching
  subSpecializations      String[]
  subSpecializationRanks  Json?            @default("{}")

  // Profil-Vollständigkeit für Qualitäts-Bonus (0-100)
  profileCompleteness Int                  @default(0)

  // Enhanced Matching Fields
  videoIntroUrl       String?              // 30-Sekunden Video-Vorstellung
  avgResponseTimeHours Int?                // Durchschnittliche Antwortzeit in Stunden
  nextAvailableSlot   DateTime?            // Nächster freier Termin
  firstSessionInfo    String?    @db.Text  // "So läuft die erste Sitzung ab"
  offersTrialSession  Boolean    @default(false) // Kostenloses/günstiges Erstgespräch
  trialSessionPrice   Int?                 // Preis für Erstgespräch (0 = kostenlos)

  // Therapie-Methoden (für spezifisches Matching)
  therapyMethods      String[]             // ["emdr", "exposure", "cbt_specific", ...]

  // Booking/Contact Stats (für ML)
  contactCount        Int        @default(0)
  bookingRate         Float?               // % der Kontakte die zu Terminen führen

  // ============================================
  // MICROSITE BUILDER FIELDS
  // ============================================

  // Status & Versionierung
  micrositeStatus        MicrositeStatus @default(draft)
  micrositeDraft         Json?           // Draft-Config als JSON
  micrositePublished     Json?           // Published-Config (Copy on Publish)
  micrositeLastSavedAt   DateTime?
  micrositePublishedAt   DateTime?

  // Hero Section
  heroLogoUrl            String?         // Premium: Logo-Upload
  heroBrandText          String?         // Name als Brand-Text
  heroBrandStyle         Json?           // {font, weight, letterSpacing, color, effect}
  heroTagline            String?
  heroCoverImageUrl      String?
  heroCtaPrimary         Json?           // {text, link, style}
  heroCtaSecondary       Json?
  heroLocationBadges     String[]

  // About Section (erweitert bestehende Felder)
  aboutRichContent       Json?           // TipTap JSON
  aboutShowLanguages     Boolean         @default(true)
  aboutShowMethods       Boolean         @default(true)
  aboutShowTargetGroups  Boolean         @default(true)

  // Kompetenzen Section
  competencies           Json?           // [{id, icon, title, description, order, visible}]

  // Angebote Section
  offerings              Json?           // [{id, title, description, price, duration}]
  showPricing            Boolean         @default(true)
  showAvailability       Boolean         @default(true)

  // Kontakt Section (erweitert)
  contactButtonText      String?
  showEmailPublic        Boolean         @default(true)
  showPhonePublic        Boolean         @default(true)
  socialLinks            Json?           // {instagram, linkedIn, xing, website}

  // Footer
  footerLegalLinks       Json?           // {impressum, datenschutz}
  showPoweredBy          Boolean         @default(true)

  // Section Order & Visibility (Premium)
  sectionOrder           String[]        // ["hero","about","competencies","offerings","contact"]
  hiddenSections         String[]

  // Erweiterte Theme-Konfiguration
  micrositeTheme         Json?           // Vollständiges Theme-Override

  // Typography (Premium)
  fontHeading            String?         // Google Font Name
  fontBody               String?

  // Layout Settings
  cornerRadius           String?         @default("md")     // sm|md|lg|xl
  cardStyle              String?         @default("glass")  // glass|solid|outline
  sectionSpacing         String?         @default("normal") // compact|normal|spacious

  // Effects (Premium)
  heroOverlayStyle       String?         @default("gradient") // gradient|blur|none
  enableTextGlow         Boolean         @default(false)

  // Profile visibility
  isPublished       Boolean      @default(true)

  // Timestamps
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt

  // Relations
  user              User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  matchInteractions MatchInteraction[]
  paymentHistory    PaymentHistory[]
  profileStats      ProfileStats[]
  contactInquiries  ContactInquiry[]

  @@index([city])
  @@index([isPublished])
  @@index([slug])
  @@map("therapist_profiles")
}

// ============================================
// BLOG MODELS
// ============================================

model BlogPost {
  id                String         @id @default(cuid())
  slug              String         @unique

  // Content
  title             String
  content           Json           // TipTap JSON content
  contentHtml       String         @db.Text // Pre-rendered HTML for SEO
  excerpt           String?        @db.Text // Auto-generated excerpt

  // Summary (Pflichtfeld)
  summaryShort      String         @db.VarChar(280) // TLDR kurz
  summaryMedium     String?        @db.Text // Mittlere Zusammenfassung

  // Media
  featuredImage     String?        // Cloudinary URL
  featuredImageAlt  String?        // Alt-Text fuer A11y

  // Meta & SEO
  metaTitle         String?        @db.VarChar(60)
  metaDescription   String?        @db.VarChar(160)
  canonicalUrl      String?

  // Reading
  readingTimeMinutes Int           @default(0)
  wordCount         Int            @default(0)

  // Statistics
  viewCount         Int            @default(0)
  uniqueViewCount   Int            @default(0)

  // Key Takeaways & Article Context
  keyTakeaways      String[]       // Array of 3-6 key points
  targetAudience    String?        @db.Text // "Für wen ist dieser Artikel?"
  learningOutcome   String?        @db.Text // "Warum ist das relevant?"

  // Review Status
  isReviewed        Boolean        @default(false)
  reviewedAt        DateTime?
  reviewedBy        String?        // Name of the reviewer

  // Status & Visibility
  status            PostStatus     @default(draft)
  publishedAt       DateTime?
  scheduledAt       DateTime?      // When to auto-publish (for scheduled status)

  // Author
  authorId          String
  author            User           @relation(fields: [authorId], references: [id], onDelete: Cascade)

  // Editor/Admin who manages this post
  editorId          String?
  editor            User?          @relation("BlogEditor", fields: [editorId], references: [id])

  // Series
  seriesId          String?
  series            BlogSeries?    @relation(fields: [seriesId], references: [id])
  seriesOrder       Int?           // Order within the series

  // Relations
  categories        BlogPostCategory[]
  tags              BlogPostTag[]
  citations         Citation[]
  comments          Comment[]
  bookmarks         Bookmark[]
  reviews           BlogReview[]
  versions          BlogPostVersion[]
  reactions         BlogReaction[]

  // Timestamps
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  @@index([authorId])
  @@index([editorId])
  @@index([status])
  @@index([publishedAt])
  @@index([scheduledAt])
  @@index([slug])
  @@index([seriesId])
  @@map("blog_posts")
}

model BlogPostVersion {
  id              String       @id @default(cuid())
  postId          String
  post            BlogPost     @relation(fields: [postId], references: [id], onDelete: Cascade)

  // Version info
  versionNumber   Int
  changeNote      String?      // Optional note about what changed

  // Snapshot of content at this version
  title           String
  content         Json
  contentHtml     String       @db.Text
  summaryShort    String       @db.VarChar(280)
  summaryMedium   String?      @db.Text

  // Who created this version
  createdById     String
  createdBy       User         @relation(fields: [createdById], references: [id])

  createdAt       DateTime     @default(now())

  @@index([postId])
  @@index([createdById])
  @@unique([postId, versionNumber])
  @@map("blog_post_versions")
}

model BlogSeries {
  id              String       @id @default(cuid())
  slug            String       @unique

  // Content
  title           String
  titleDE         String
  titleEN         String
  description     String?      @db.Text
  descriptionDE   String?      @db.Text
  descriptionEN   String?      @db.Text

  // Media
  coverImage      String?
  coverImageAlt   String?

  // Status
  isPublished     Boolean      @default(false)

  // Author
  authorId        String
  author          User         @relation(fields: [authorId], references: [id])

  // Posts in this series
  posts           BlogPost[]

  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  @@index([authorId])
  @@map("blog_series")
}

model BlogReaction {
  id              String       @id @default(cuid())
  postId          String
  post            BlogPost     @relation(fields: [postId], references: [id], onDelete: Cascade)

  // User (optional - allow anonymous reactions)
  userId          String?
  user            User?        @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Reaction type
  type            String       // "like", "love", "insightful", "helpful"

  // For anonymous users, store a hash of IP/fingerprint
  anonymousId     String?

  createdAt       DateTime     @default(now())

  @@unique([postId, userId, type])
  @@unique([postId, anonymousId, type])
  @@index([postId])
  @@index([userId])
  @@map("blog_reactions")
}

model BlogCategory {
  id              String              @id @default(cuid())
  slug            String              @unique
  name            String              // Internal name
  nameDE          String              // German translation
  nameEN          String              // English translation
  description     String?             @db.Text
  descriptionDE   String?             @db.Text
  descriptionEN   String?             @db.Text
  color           String?             // Hex color for UI
  icon            String?             // Lucide icon name
  sortOrder       Int                 @default(0)

  // SEO
  metaTitleDE     String?             @db.VarChar(60)
  metaTitleEN     String?             @db.VarChar(60)
  metaDescDE      String?             @db.VarChar(160)
  metaDescEN      String?             @db.VarChar(160)

  posts           BlogPostCategory[]

  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  @@map("blog_categories")
}

model BlogPostCategory {
  postId          String
  categoryId      String
  post            BlogPost            @relation(fields: [postId], references: [id], onDelete: Cascade)
  category        BlogCategory        @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@id([postId, categoryId])
  @@map("blog_post_categories")
}

model BlogTag {
  id              String              @id @default(cuid())
  slug            String              @unique
  name            String

  posts           BlogPostTag[]

  createdAt       DateTime            @default(now())

  @@map("blog_tags")
}

model BlogPostTag {
  postId          String
  tagId           String
  post            BlogPost            @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag             BlogTag             @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([postId, tagId])
  @@map("blog_post_tags")
}

model Citation {
  id              String              @id @default(cuid())

  // DOI Support
  doi             String?

  // Bibliographic Data
  title           String
  authors         String[]            // Array of author names
  journal         String?
  year            Int?
  volume          String?
  issue           String?
  pages           String?
  publisher       String?
  url             String?
  accessDate      DateTime?

  // Citation Type
  type            String              @default("article") // article, book, website, etc.

  // Formatted citations (cached)
  formattedAPA    String?             @db.Text

  // Relation to post
  postId          String
  post            BlogPost            @relation(fields: [postId], references: [id], onDelete: Cascade)

  // Position in post (for inline citations)
  inlineKey       String              // e.g. "smith2023" for [Smith, 2023]

  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  @@index([postId])
  @@index([doi])
  @@map("citations")
}

model Comment {
  id              String              @id @default(cuid())
  content         String              @db.Text

  // Author (registered user or guest)
  authorId        String?
  author          User?               @relation(fields: [authorId], references: [id], onDelete: SetNull)
  guestName       String?
  guestEmail      String?

  // Post relation
  postId          String
  post            BlogPost            @relation(fields: [postId], references: [id], onDelete: Cascade)

  // Nested comments
  parentId        String?
  parent          Comment?            @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies         Comment[]           @relation("CommentReplies")

  // Moderation
  isApproved      Boolean             @default(false)
  isSpam          Boolean             @default(false)

  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt

  @@index([postId])
  @@index([authorId])
  @@index([parentId])
  @@map("comments")
}

model Bookmark {
  id              String              @id @default(cuid())

  userId          String
  user            User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  postId          String
  post            BlogPost            @relation(fields: [postId], references: [id], onDelete: Cascade)

  // Reading progress
  readProgress    Float               @default(0) // 0-100%
  lastReadAt      DateTime?

  createdAt       DateTime            @default(now())

  @@unique([userId, postId])
  @@index([userId])
  @@map("bookmarks")
}

model BlogDraft {
  id              String              @id @default(cuid())

  // Link to existing post (null for new posts)
  postId          String?             @unique

  // Author
  authorId        String
  author          User                @relation(fields: [authorId], references: [id], onDelete: Cascade)

  // Draft content
  content         Json                // TipTap JSON
  title           String?
  summaryShort    String?             @db.VarChar(280)

  // Autosave metadata
  savedAt         DateTime            @default(now())

  @@index([authorId])
  @@map("blog_drafts")
}

model BlogReview {
  id          String    @id @default(cuid())

  // The post being reviewed
  postId      String
  post        BlogPost  @relation(fields: [postId], references: [id], onDelete: Cascade)

  // The admin who reviewed
  reviewerId  String
  reviewer    User      @relation(fields: [reviewerId], references: [id])

  // Review outcome
  status      String    // "approved", "changes_requested", "rejected"
  feedback    String?   @db.Text

  createdAt   DateTime  @default(now())

  @@index([postId])
  @@index([reviewerId])
  @@map("blog_reviews")
}

// ============================================
// MATCHING & ML MODELS
// ============================================

// Anonyme Interaktions-Daten für ML-Optimierung
model MatchInteraction {
  id              String   @id @default(cuid())
  sessionId       String   // Anonyme Session-ID (ohne User-Zuordnung)
  therapistId     String
  therapist       TherapistProfile @relation(fields: [therapistId], references: [id], onDelete: Cascade)

  // Interaktionstyp
  action          String   // "view" | "click" | "contact"

  // Kontext zum Zeitpunkt der Interaktion
  matchScore      Int?
  searchCriteria  Json?    // Anonymisierte Matching-Kriterien

  timestamp       DateTime @default(now())

  @@index([sessionId])
  @@index([therapistId])
  @@index([timestamp])
  @@map("match_interactions")
}

// Anonymes Nutzer-Feedback nach Matching
model MatchFeedback {
  id              String   @id @default(cuid())
  sessionId       String   // Anonyme Session-ID

  // Feedback-Daten
  foundMatch      Boolean? // "Haben Sie jemanden gefunden?"
  relevanceRating Int?     // 1-5 Sterne

  // Optional: Freitext-Feedback
  feedbackText    String?  @db.Text

  timestamp       DateTime @default(now())

  @@index([sessionId])
  @@index([timestamp])
  @@map("match_feedback")
}

// Contact Inquiry from Matching Wizard (GDPR-compliant)
model ContactInquiry {
  id              String   @id @default(cuid())

  // Therapist relation
  therapistId     String
  therapist       TherapistProfile @relation(fields: [therapistId], references: [id], onDelete: Cascade)

  // Contact details
  name            String
  email           String
  phone           String?
  message         String   @db.Text

  // Matching context (for therapist reference)
  selectedTopics    String[]
  selectedSubTopics String[]
  matchScore        Int?

  // Optional intensity (with GDPR consent)
  intensityLevel       String?    // "low" | "medium" | "high"
  intensityDescription String?   @db.Text
  intensityConsent     Boolean   @default(false)

  // Status
  status          String   @default("new")  // new, read, replied, archived

  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([therapistId])
  @@index([status])
  @@index([createdAt])
  @@map("contact_inquiries")
}

// ============================================
// SUBSCRIPTION & BILLING
// ============================================

// Zahlungshistorie für Tier-Wechsel
model PaymentHistory {
  id        String           @id @default(cuid())
  profileId String
  profile   TherapistProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  // Payment Details
  amount    Int              // In Cents (2900 = 29€)
  currency  String           @default("eur")
  status    String           // succeeded, failed, refunded
  tier      AccountType      // Ziel-Tier
  action    String           // upgrade, downgrade, renew, cancel

  // Mock Stripe Reference
  stripePaymentId String?

  createdAt DateTime         @default(now())

  @@index([profileId])
  @@index([createdAt])
  @@map("payment_history")
}

// ============================================
// PROFILE STATISTICS (Premium Feature)
// ============================================

// Tägliche Statistiken für Therapeuten-Profile
model ProfileStats {
  id            String           @id @default(cuid())
  profileId     String
  profile       TherapistProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  // Datum für tägliche Aggregation
  date          DateTime         @db.Date

  // Zähler
  views         Int              @default(0)  // Direkte Profilaufrufe
  impressions   Int              @default(0)  // Anzeigen in Suchergebnissen
  contactClicks Int              @default(0)  // Klicks auf Kontakt-Buttons
  profileClicks Int              @default(0)  // Klicks vom Suchergebnis zum Profil

  // Timestamps
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  @@unique([profileId, date])
  @@index([profileId])
  @@index([date])
  @@map("profile_stats")
}

// ============================================
// LABELLING PORTAL MODELS
// ============================================

// Versionierte Taxonomie für Kategorien/Subkategorien/Intensitätsfragen
model TaxonomyVersion {
  id          String    @id @default(cuid())
  version     String    @unique  // z.B. "v0.1", "v0.2"
  description String?
  schema      Json      // Snapshot der kompletten Taxonomie (topics, subtopics, intensity)
  isActive    Boolean   @default(false)
  createdAt   DateTime  @default(now())

  // Relations
  labels      Label[]
  modelRuns   ModelRun[]

  @@map("taxonomy_versions")
}

// Fälle (Texte) die gelabelt werden sollen
model LabellingCase {
  id          String      @id @default(cuid())
  text        String      @db.Text
  source      CaseSource  @default(MANUAL)
  language    String      @default("de")  // ISO 639-1
  status      CaseStatus  @default(NEW)
  metadata    Json?       // Optional: Quelle, Kontext, etc.

  // Ersteller
  createdById String
  createdBy   User        @relation("CreatedCases", fields: [createdById], references: [id])

  // Timestamps
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  labels          Label[]
  calibrationPool CalibrationPool?

  @@index([status])
  @@index([createdById])
  @@index([source])
  @@map("labelling_cases")
}

// Labels für Fälle (append-only mit Supersession für Audit-Trail)
model Label {
  id                 String           @id @default(cuid())

  // Fall-Referenz
  caseId             String
  case               LabellingCase    @relation(fields: [caseId], references: [id], onDelete: Cascade)

  // Rater (wer hat gelabelt)
  raterId            String
  rater              User             @relation("RatedLabels", fields: [raterId], references: [id])

  // Taxonomie-Version zum Zeitpunkt des Labelns
  taxonomyVersionId  String
  taxonomyVersion    TaxonomyVersion  @relation(fields: [taxonomyVersionId], references: [id])

  // Haupt-Kategorien mit Priorisierung (max 3)
  // Format: [{key: "depression", rank: 1}, {key: "anxiety", rank: 2}]
  primaryCategories  Json

  // Sub-Kategorien pro Haupt-Kategorie
  // Format: {"depression": ["chronic_sadness", "grief"], "anxiety": ["panic_attacks"]}
  subcategories      Json

  // Intensitätsfragen pro Haupt-Kategorie (optional, nur wenn im Text erkennbar)
  // Format: {"depression": ["dep_daily", "dep_sleep"], "anxiety": ["anx_panic"]}
  intensity          Json

  // Related Topics (häufig zusammenhängend, separat von Labels)
  // Format: [{key: "sleep", strength: "OFTEN"}, {key: "stress", strength: "SOMETIMES"}]
  relatedTopics      Json?

  // Unsicher-Flag
  uncertain          Boolean          @default(false)

  // Evidenz-Snippets (Textausschnitte die Entscheidung begründen)
  // Format: [{start: 10, end: 50}, {start: 100, end: 150}]
  evidenceSnippets   Json?

  // Audit-Trail: Supersession-Kette (append-only)
  // Wenn ein Label aktualisiert wird, wird ein neues Label erstellt
  // das auf das alte verweist
  supersededById     String?          @unique
  supersededBy       Label?           @relation("LabelSupersession", fields: [supersededById], references: [id])
  supersedes         Label?           @relation("LabelSupersession")

  createdAt          DateTime         @default(now())

  @@index([caseId])
  @@index([raterId])
  @@index([taxonomyVersionId])
  @@map("labels")
}

// Kalibrierungs-Pool: Fälle die von mehreren Ratern gelabelt werden
model CalibrationPool {
  id       String        @id @default(cuid())
  caseId   String        @unique
  case     LabellingCase @relation(fields: [caseId], references: [id], onDelete: Cascade)
  isActive Boolean       @default(true)
  addedAt  DateTime      @default(now())

  @@map("calibration_pool")
}

// Modell-Läufe für Baseline-Training
model ModelRun {
  id                String            @id @default(cuid())
  method            String            // "knn" | "logreg"
  parameters        Json?             // z.B. {"k": 5, "threshold": 0.5}
  metrics           Json?             // {top3_accuracy, macro_f1, per_label_recall}
  artifactPath      String?           // Pfad zu gespeicherten Artefakten

  // Taxonomie-Version für diesen Lauf
  taxonomyVersionId String?
  taxonomyVersion   TaxonomyVersion?  @relation(fields: [taxonomyVersionId], references: [id])

  // Status
  status            String            @default("pending")  // pending, running, completed, failed
  error             String?           @db.Text

  // Wer hat den Lauf gestartet
  triggeredById     String
  triggeredBy       User              @relation("TriggeredModelRuns", fields: [triggeredById], references: [id])

  // Timestamps
  startedAt         DateTime          @default(now())
  completedAt       DateTime?

  @@index([status])
  @@index([method])
  @@map("model_runs")
}
